
### 1. What are RB Trees?
- Balanced binary search tree 
- Each node has the following attributes
	- Value/Key
	- left child
	- right child
	- parent 
	- color
- Properties
	- All nodes in a RB tree should be red or black
	- (can be violated on insert) The root node is always black
	- All leaf nodes will point to sentinel nodes 
		- All sentinel nodes are black
	- (can be violated on insert) Red node can only have black children, i.e. parent of a red node is always black
	- For all nodes in an RB tree, the path from a particular node to the leaf nodes should have the same number of black nodes (excluding the node itself when considering the number of black nodes)
		- This is called the black height from a particular node
- RB tree insertion loop variant. Where z is the newly inserted node
	- Node z is red
	- if z.p is root, z.p is black
	- The RB tree after inserting the new node either violates property 2 or violates property 4 or none of the properties are violated
- To prove that the insert works:
	- Initialisation: Check if the invariant is true before the start of the loop
	- Termination: When the loop terminates, all the RB Tree properties are preserved 
	- Maintenance: After each iteration, the loop invariant is still satisfied

### 2 Insert:
- Insert like normal BST
- If the parent of the new node(z) is red, then do a RB tree fix-up
- In the RB Tree fix-up, 
	- z: current node/newly inserted node
	- y: uncle
	- Repeat the following two steps until z.p is red or z.p is null (i.e. the z node is the root)
	- When y.color = RED (easiest case)
		- Color z.p and y as black
		- Color z.p.p as red
		- Make z point to z.p.p
	- When y.color = black
		- Case a: (z is to the left of grandparent and z is to the right of the parent)
			- Make z point to z.p 
			- Convert this to case b using left rotate over z
		- Case b: (z is to the left of grandparent and z is to the left of parent) 
			- Color z.p as black
			- Color z.p.p as red
			- Right rotate over z.p.p
		- Case c: (z is to the right of grandparent and z is to the left of the parent)
			- Make z point to z.p
			- Convert this to case d using a left over z
		- Case d: (z is to the right of grandparent and z is the right of the parent)
			- Same as case b but with left and right exchanged
			- Color z.p as black
			- Color z.p.p as red
			- Left rotate over z.p.p
	- End of repeat
	- Color the root of the tree black
- End of insertion algo
#### 2.1 Insertion explanation
- For case b and d when y is black
	- There is a red red violation in z and z.p
	- Converting z.p to black resolves the red red violation
	- As we converted z.p as black, make the grandparent red
	- Perform a right rotate over on grandparent will make the z.p (black node) move up, this will not cause any red red violation since z.p is a black node
	- Converting the z.p.p to red will not have red red violations, we execute this case only if the uncle y is black
- when y is red: 
	- If the y.color is red, then
	- The z.p.p is a black node
	- The z.p is red, and z is red, z is a new node so it is always red, fix-up is done only if the z.p is red
	- We make the grandparent red and make the z.p and y back, this will not affect the black height z.p.p
#### 2.2 When does the black height increase?
- Every time the red node propagates to the root, the black height will increase

### 3. Deletion in red black trees
- The node to delete is z
- The node y is
	- z if z has 1 child
	- the successor of z if z has two children
- The node that takes y's original place in the tree is x
- The sibling of x is w 
- Delete is similar to the BST delete. We will need to perform a fix up if the y's original color is black. 
	- When there is only one child for z, then we only check the color of z. If the color of z is black, then we will need to perform delete fix-up
	- To delete z with two children, we will replace z with y, which is the successor of z. 
	- y will be painted with the color of z after replacement(but to check if we need to perform the fix-up we will use the original color of the y)
		- If y was black before replacement, then we will need to perform a delete fix-up
		- If y was red before replacement, then we don't need to perform a delete fix-up
- If y's original color is black, perform the RB tree delete fix-up
- Repeat the following steps until x.color == black and x != root
	- Case 1: w's color is red 
		- Convert this to case 2 using rotations
		- Color x.p red
		- Color w black, do a rotation such that the current w becomes the grandparent of x
		- Update w to be the sibling of x
		- How does these operations convert case 1 to case 2/3/4?
			- If w is red, the both the children of w and w.p should be black
			- Note that w.p and x.p is same as w and x are siblings
			- We convert w.p to red and w to black, then make a rotation such that w comes up
			- While doing this rotation, one the black children of w, will now be the sibling of x, which converts it to case 2/3/4
	- Case 2: w is black, w's children are both black
		- Change color of w to red
		- Change x to x.p
	- Case 3: x is to the left of x.p 
		- Case 3(i): w is black, w's right child is black 
			- Color w to red, color w's left child to black
			- Right rotate on w
			- Update the w pointer to point to x's sibling
			- This will convert to case 3(ii)
		- Case 3(ii): w is black, w's right child is red
			- w inherits w.p's color
			- Color w.p as black and w.right as black
			- Left rotate on w.p
			- Set x as Tree root
	- Case 4: x is to the right of x.p
		- Case 4(i): w is black and, w's left child is black
			- Same as case 3(i), interchange left and right
		- Case 4(ii): w is black and w's left child is red
			- Same as case 3(ii), interchange left and right
- End repeat
- Color the node pointing to x as black

#### 3.1 When does the black height decrease?
- This happens every time the x node propagates to the root node