
#### 1 Principles of reliable data transfer
- Error free Data
	- Data should not be corrupted
- Lossless transfer 
	- All the data sent by the sender should be received by the receiver
- Preserving message orders
	- When sender sends two messages to a receiver 
		- The receiver should receive the messages in the same order that the sender sent the messages

#### 2 Principles for Reliable Data transfer

##### 2.1 Iteration 1: Completely reliable transmission medium
- **Transmission Medium Properties:**
	- The layers below TCP reliably transfer the data with no errors
	- No packet losses
		- No packet is lost on transit
		- The receiver can receive all the data at the rate at which the sender sends them
- **Events**
	- **Sender**
		- Triggering event
			- An application will call the rdt_send() function
				- rdt: reliable data transfer
		- Actions taken
			- Make segments using make_packet() function
			- send packet using udt_send() function
				- udt: unreliable data transfer
	- **Receiver**
		- Triggering event
			- Underlying layer receives packet and calls rdt_receive()
		- Actions taken
			- extract_data() from segment
			- deliver_data() to the application

##### 2.2 Iteration 2: Error prone transfer medium
- **Transmission Medium Properties:**
	- Data errors
		- The transfer medium introduces bit errors in the data
	- No packet losses
		- No packet is lost on transit
		- The receiver can receive all the data at the rate at which the sender sends them
- **How to handle errors?**
	- Receiver check for errors 
		- How does the receiver check for errors:
			- Using a checksum field
		- If no error 
			- send +ve ack 
		- If error 
			- send -ve ack
	- Sender receives ack  
		- Check for -ve ack and retransmit packets 
- **Events**
	- **Sender**
		- Triggering event
			- An application will call the rdt_send() function
				- rdt: reliable data transfer
		- Actions taken
			- Make segments using make_packet() function add error detection bits to each packet
			- Send packet using udt_send() function
				- udt: unreliable data transfer
			- Wait for ack from receiver
				- If +ack: send next packet
				- if -ack: resend the packet and wait for ack
	- **Receiver**
		- Triggering event
			- Underlying layer receives packet and calls rdt_receive()
		- Actions taken
			- If No error in packet
				- make_packet() for +ack
			- If error in packet
				- make_packet() for -ack
			- udt_send() ack packet 
			- extract_data() if packet has no errors
			- deliver_data() to the application once all packets are received
- **Stop and wait protocol**
	- Sender sends packet and waits for ack 
- **Problem: ACK has errors**
	- If ACK has errors, sender will not know if it is a +ve or -ve ack
		- Sender sends packet again
		- **How to handle duplicate packets**
			- Add **sequence number** to each packet
			- If the packet with sequence number is already received 
				- Receiver discards packet as duplicate 
				- Receiver sends +ack to sender 

##### 2.3 Iteration 3: Lossy and Error prone Transmission medium
- **Transmission Medium Properties:**
	- Data errors
		- The transfer medium introduces bit errors in the data
	- Packet losses
		- Packets are lost on transit
	- Receiver's packet rate 
		- If the sender sends packets at a high rate, receiver might drop packets due to limited processing capabilities 
- **Events**
	- **Sender**
		- Triggering event
			- An application will call the rdt_send() function
				- rdt: reliable data transfer
		- Actions taken
			- Make segments using make_packet() function add error detection bits and sequence number to each packet 
			- Send packet using udt_send() function
				- udt: unreliable data transfer
			- Wait for ack from receiver
				- If +ack: send next packet
				- if -ack: resend the packet and wait for ack
				- If ack not received after certain time: resend the packet and wait for ack
	- **Receiver**
		- Triggering event
			- Underlying layer receives packet and calls rdt_receive()
		- Actions taken
			- Check errors in packet
				- No error: make_packet() for +ack
				- If error: make_packet() for -ack
			- udt_send() ack packet
			- Check sequence number for packet
				- if duplicate: discard packet
				- if not duplicate: extract_data() from packet
			- deliver_data() to the application once all packets are received
- **Problem: Resource under utilization**
	- The sender sends a packet and waits for RTT + N/R time
		- RTT: Round trip time
		- N: size of packet
		- R: transmission rate
	- The link will be under utilized
	- **How to resolve this issue?**
		- Send multiple packets at once

#### 3 Pipelined reliable data transfer 
- Send multiple packets at once and wait for ack 
- There are two approaches
	- Go back N
	- Selective repeat
- **Concepts common for both approaches**
	- Sliding window
		- Sender sends a max of N packets and waits for ack
		- Here the window size is N
		- How is it represented:
			- The start of the window: oldest packet that did not receive ack
			- The window size is represented by N
			- nextSeqnum: represents the next packet to send
	- Both approaches does not use -ve ack

##### 3.1 Go back N
- **Sender**
	- **Events:**
		- rdt_send() is called from upper layer
			- if window size is
			- Less than or equal to N: 
				- construct and send packet
				- update nextSeqNum
			- Greater than N: do nothing
		- Receive ack
			- Update oldest unacknowledged packet to the largest ack seqNum+1
				- What if an ack with seqNum(seqNum<largest seqNum from receiver) is lost
					- This is not a problem as the receiver does not accept out of order packets
		- Time out
			- If the oldest seqNum did not receive ack after some time
				- Send the entire window of packets
- **Receiver**
	- **Trigger Event**: 
		- rdt_receive(): from underlying layer
	- **Actions taken:**
		- Check errors in packet
			- If error: discard packet
		- Check sequence number for packet
			- if duplicate: discard packet
			- If out of order:
				- If the least seqNum of the packet not received is **t**
					- Accept packet only if packet seqNum = t, else discard packet
					- When discarding packet send a duplicate ack for the last packet that was received in order
		- Construct and send the ack for the in order packets received 
		- deliver_data() to the application once all packets are received
- Using cumulative ack
	- GBN uses cumulative ack
	- If receiver sends ack 4, 5, 6 and 5 is lost before reaching the sender
	- The sender can conclude that 5 is received correctly because it received ack 6(i.e. all packets with seqNum <= 6 have been received) 

##### 3.2 Selective repeat
- **Sender**
	- **Events:**
		- rdt_send() is called from upper layer
			- if window size is
			- Less than or equal to N: 
				- construct and send packet
				- update nextSeqNum
			- Greater than N: do nothing
		- Receive ack
			- Track ack received for each packet in window
			- Update oldest unacknowledged seqNum accordingly  
		- Time out
			- Timer for each packet in window
				- Send only the packets that did not receive ack within time out
- **Receiver**
	- **Trigger Event**: 
		- rdt_receive(): from underlying layer
	- **Actions taken:**
		- Check errors in packet
			- If error: discard packet
		- Check sequence number for packet
			- Track what packets are received
			- Send ack to all the packets that are received that have seqNum less than the max window size 
			- if duplicate: discard packet 
				- still send ack for that particular packet to ensure that the ack is received by the sender
		- deliver_data() to the application once all packets are received
- **Note**: SR does not use cumulative ack, the ack contain the seq number of the packet received. Therefore each packet needs to receive a corresponding ack
- **Max limit for window size:**
	- 0 ≤ window size ≤ seqNum/2
	- Here the max possible seqNum is determined the protocol used
		- Each protocol will have a max limit for the number of bits used to represent seqNum
- **Packet Reordering**:
	- Some packets can be received in a different order
		- Instead of 0, 1, 2 -> 1, 2, 0 can be received
	- To prevent and old packet to be received (window is already moved to the new packet seqNum)
		- Using time stamps described in [RFC 1323](https://datatracker.ietf.org/doc/html/rfc7323#section-5)
