#### 1 Transport Layer
- **Where in the TCP/IP stack does this layer reside?**
	- This layer is between the application layer and network layer
- **Role of TCP layer
	- Process to process communication
		- The two different hosts(using application layer protocols) are not concerned about how the messages are sent to the other host
- **What Happens an application sends a message?**
	- An application sends a message to another application running on a different host
		- There can be many applications sending a message from the same host 
	- This message is broken into pieces and TCP headers are added
		- Each piece with its headers are known as **segments**
	- This segment travels through the network
		- The TCP layer is also not concerned about how the message reaches the other host
		- When message reaches other host, TCP is responsible to send message to the correct the socket
	- In the destination host the network layer extracts the TCP segment from the packets
	- The TCP layer 
		- Combines all the segments and delivers the message to the correct application at the destination host 
		- **Does the TCP layer directly deliver the message to the application?**
			- No, Messages are sent to the socket
			- Explained in next section [[#2 Transport layer multiplexing and demultiplexing]]

#### 2 Transport layer multiplexing and demultiplexing
- **What is demultiplexing?**
	- Process in which TCP layer sends the receiving message to the correct socket
		- As mentioned earlier the TCP layer does not send the message to an application
		- Instead it sends the message to the socket that is associated with the application
- **What is multiplexing?**
	- Process in which TCP layer 
		- Gathers messages from different sockets that are associated with applications 
		- Segments each message with appropriate headers
		- Sends the segments through the network
	- **NOTE:** there multiplexing and demultiplexing at each layer. For example IP multiplexes using a 5 tuple (protocol, src IP, src port, dst IP, dst port) 
- **Connectionless de/multiplexing**
	- UDP uses this 
	- A socket is identified by a two element tuple
		- Destination IP addr
		- Destination port
	- This means when two segments are sent with the same destination IP addr and destination socket: 
		- At the destination both segments are collected from the same destination socket even if the source addr and ports are different
- **Connection Oriented de/multiplexing**
	- TCP uses this
	- A socket is identified by 4 tuple
		- Source IP addr
		- Source port
		- Destination IP addr
		- Destination port
	- Connection is point to point
		- This means when two application send a request with different IP addr: 
			- At the destination a different socket is used for each tuple that has different source addr and/or port
		- Similarly, the sender process cannot send a message to two destinations with a single port 
- **How does the TCP layer distinguish between sockets?**
	- **Can two sockets be bind to the same port number?**
		- No
		- Two sockets cannot be bind to the same port number using the bind() system call
	- **Can two sockets have the same port number?**
		- Yes, two sockets can have the same port number
		- As mentioned earlier, each socket is identified using a 4 tuple (dst IP, dst port, src IP, src port)
		- Example using a client and server
			- Server has a socket listening to incoming connection requests port 123.123.123.123::11000
			- Client creates a socket 100.100.100.100::12345 
			- Client connects to the server using the server IP and port
			- Server accepts the connection using the listening socket, this creates a new socket in the server
				- The new socket will have the same port 11000
				- But the new socket will be identified using (123.123.123.123, 11000, 100.100.100.100, 12345)
				- This new socket will be used to communicate with the client process running in 100.100.100.100::12345
			- When a new client connects, another socket with the different src IP::port will be created 
	- **What is the maximum number of clients a server can connect to?**
		- There is no limit based on the port number, because for each new client connection the port at the server remain the same
		- Theoretically the number of clients the server can connect to is the number of unique combinations of client IP and client port. This is the limit for each IP and port at the server

#### 3 UDP - [RFC768](https://datatracker.ietf.org/doc/html/rfc768/)
- UDP is 
	- Connectionless
		- Unlike TCP, UDP does not have a handshake protocol before exchanging messages
	- UDP is **not a byte oriented protocol**
		- In UDP, the data is considered in octets
		- The UDP length field will represent the **number of octets of data** and **not the number of bytes** 
	- lightweight
		- The UDP layer adds only the source and destination port address
	- Fast
		- There is no handshaking unlike TCP
			- The DNS uses UDP because UDP is faster compared to TCP
		- Unlike TCP there is no congestion control
			- This is useful in SNMP protocol to send messages when network congestion is high
	- **Drawback:**
		- UDP can keep sending datagrams even if the network is congested, this limits the rates for TCP connections
		- Unreliable
			- UDP does not guarantee the delivery of the message 
			- UDP does not guarantee that no duplicate messages were sent to destination
			- This puts the burden on the application developer to create mechanisms for reliable data transfer 
- UDP data segment structure
	- 16 bit src port
	- 16 bit dst port
	- 16 bit length
		- Length of the data(if value is 1, the 1 octet data is present in the data field)
	- 16 bit check sum
		- 16 bit ones complement sum of the all the 16 bit words in the UDP segment
	- Data octets